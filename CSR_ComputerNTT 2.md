https://www.coursera.org/learn/nand2tetris2/lecture/4XUSB/unit-0-6-low-level-programming-part-i

# Unit 1.8: VM Implementation on the Hack Platform
2025/09/08

0500<->1000

- moving along

# Unit 1.8: VM Implementation on the Hack Platform
2025/09/06

0000<->0500

# Unit 1.7: VM Implementation on the Hack Platform
2025/09/07

0500<->1000 End

- general accepted standard

# Unit 1.7: VM Implementation on the Hack Platform
2025/09/05

0300<->0800 End

- perform objective testing
- respective

# Unit 1.7: VM Implementation on the Hack Platform
2025/09/04

0000<->0500

- assembly code get translation from vm code
- java parser class, code writer class, main class

# Unit 1.7: VM Implementation on the Hack Platform
2025/09/03

0500<->1000 End

- standard VM enable one team to develop and another team to test
- host computer

# Unit 1.7: VM Implementation on the Hack Platform
2025/09/02

0000<->0500

- arithmatic, logic; memory access; branching; function

# Unit 1.6: The VM Emulator
2025/09/01

1800<->2300 End

- what is supposed to be doing
- if they are in agreement

# Unit 1.6: The VM Emulator
2025/08/31

1500<->2000

- fast forward
- single step it

# Unit 1.6: The VM Emulator
2025/08/29

1000<->1500

- initial setup

# Unit 1.6: The VM Emulator
2025/08/28

0500<->1000

- 149.0
- function/return envolope make sequence of instructions to be a program
- Understanding the difference between a sequence of instructions and a program is essential as you dive into the world of computer science. 

A sequence of instructions is simply a list of commands that a computer can execute, one after the other. Think of it like a recipe that tells you to add ingredients in a specific order. However, this sequence may not have a clear structure or purpose beyond just executing those commands. It’s like following a list of tasks without knowing how they fit into a larger goal.

On the other hand, a program is a more organized and complete set of instructions designed to perform a specific task or solve a problem. It’s like a well-planned meal that not only includes the recipe but also considers the timing, presentation, and how each dish complements the others. A program typically includes functions, control structures, and data management, making it capable of handling complex operations and user interactions.

In summary:

Sequence of Instructions: A simple list of commands without a clear structure or purpose.
Program: A structured set of instructions designed to perform a specific task, often including functions and control logic.

# Unit 1.6: The VM Emulator
2025/08/27

0000<->0500

# Unit 1.5: VM Implementation: Memory Segments
2025/08/26

2100<->2600 End

- keep address of this and that in pointer
- that7???
- 149.36

# Unit 1.5: VM Implementation: Memory Segments
2025/08/23

2000<->2500

- temp, temporary variable

# Unit 1.5: VM Implementation: Memory Segments
2025/08/23

1500<->2000

- static variable, the order of the index is different than the order of RAM

# Unit 1.5: VM Implementation: Memory Segments
2025/08/21

1500<->2000

- static variable can be seen by all VM programs
- static variables is out of stack
- TBRT
- platform agonostic

# Unit 1.5: VM Implementation: Memory Segments
2025/08/21

1000<->1500

- constant memory segment
- asterisk

# # Unit 1.5: VM Implementation: Memory Segments
2025/08/19

0500<->1000

# Unit 1.5: VM Implementation: Memory Segments
2025/08/19

0000<->0500

- 257 still has garbage in the stack, but the 257 has voided, as the next push would kill it

# Unit 1.5: VM Implementation: Memory Segments
2025/08/18

0000<->0500

- TBRT

# Unit 1.5: VM Implementation: Memory Segments

2025/08/17

0000<->0500

- SP stack pointre
- LCL local segment
- TBRT

# Unit 1.4: VM Implementation: the Stack
2025/08/15

1200<->1700 End

# Unit 1.4: VM Implementation: the Stack
2025/08/15

1000<->1500

- The last two lines show you, the pointer SP hold value 1 greather than previously
- general implementation

# Unit 1.4: VM Implementation: the Stack
2025/08/14

0500<->1000

# Unit 1.4: VM Implementation: the Stack

2025/08/12

0000<->0500

- pointer manipulation

# Unit 1.3: VM Abstraction: Memory Segments

2025/08/12

0500<->1000 End

- concepts layed on step on top of another has multiplied value

# Unit 1.3: VM Abstraction: Memory Segments

2025/08/11

0000<->0500

- y argument, c local variable, s1,s2 static variable
- VM abstraction wouldn’t retain variable name

# Unit 1.2: VM Abstraction: the Stack
2025/08/10

1000<->1500 End

- concept one one layer on top of another but all exist
- push 2, push 9 sub is 2-9
- in hack vm, true and false is written as true and false

# Unit 1.2: VM Abstraction: the Stack
2025/08/08

0500<->1000

- compiler do the job to translate x=17+19 into push 17 and things

# Unit 1.1: Program Compilation Preview
2025/08/08

0000<->0500

- two conflicting objectives
- find the right balance
- stack machine is a good way to handle it
- can only access plate from the top
- stack is also with a memory
- to the stack but nothing happen to the memory

# Unit 1.1: Program Compilation Preview

2025/08/07

0000<->End

- maintain multiple version of your code
- the idea is to write once and run anywhere
- java has two tier compilation
- imaginary computer
- equip the target device with JVM implementation
- take byte code into target platform
- bytecode
- introducing a intermediate step
- VM code, bytecode
- VM emulator, VM translator
- universal turing machine can emulate any individual machine
- thinking about thinking
- program that can analyze program
- reason about reasoning

# Unit 1.0: The Road Ahead

1500<->End

2025/08/06

- OS closes gap between high level programing and barebones

# Unit 1.0: The Road Ahead
1000<->1500

2025/08/05

- constructor
- .something is called extension

# Unit 1.0: The Road Ahead

0500<->1000

2025/08/04

- API
- class
- you know how to do it, because you have API

# Unit 1.0: The Road Ahead

2025/08/03

0000<->0500

- JUMP to this course from yesterday’s progress
- signify a loop

# Module 2
Unit 0.7: Low-Level Programming, Part II

2025/08/02

0330<->0830

- symbolic labeling
- assembler and translator

# Module 2
Unit 0.7

2025/08/01

0000<->0330

- branching, variable, iteration
- brancing decide to jump or not

# Module 2
Unit 0.6: Low-Level Programming, Part I

2230<->2400 End 

2025/08/01

# # Module 2
Unit 0.6: Low-Level Programming, Part I

1730<->2230

2025/07/31

- 16 virtual registers
- use A register as a data register
- symbols is to denote the fact to be more explicitly

# Module 2

Unit 0.6: Low-Level Programming, Part I

1230<->1730

2025/07/30

- indentation
- comments and white spaces
- 1630 mins, hacker mentioned
- nope, null instruction
- computer is always doing something
- end computer with infinite loop
- end every program with inifite loop


# Module 2
Unit 0.6: Low-Level Programming, Part I

0730<->1230

2025/07/29

# Module 2
Unit 0.6: Low-Level Programming, Part I

0230<->0730

2025/07/28

- CPU emulator
- d data register, a address data register
- M currently selected memory register

# Module 2
Unit 0.6: Low-Level Programming, Part I

2025/07/27

0000<->0230

- compute, store, jump
- week6 ntt1, about assembler

# Module 2
Unit 0.5: Handling Input and Output

2025/07/25

1900<->2400

- probe the contents of the keyboard chip
- read only chip

# odule 2
Unit 0.5: Handling Input and Output

2025/07/25

1400<->1900


# Module 2
Unit 0.5: Handling Input and Output

2025/07/24

0900<->1400

# Module 2
Unit 0.5: Handling Input and Output

0400<->0900

2025/07/23

- screen chip

# Module 2
Unit 0.5: Handling Input and Output

0000<->0400

2025/07/22

- screen memory map

# Module 2
Unit 0.4: Hack Language Specification

0500<->1000 End

2025/07/21

# Module 2
Unit 0.4: Hack Language Specification

0000<->0500

2025/07/20

- hack program, written in
- assembler
- A instruction 0 value, where value is 15 bit long
- op code, and not used
- ALU, arithmetic logic unit

# Module 2
Unit 0.3: The Hack Computer and Machine Language

2025/07/19

0500<->1500 End

- D register
- A register
- M register
- A instruction, set A register to RAM 21
- @100,M=-1
- C instruction, workhouse
- dest = comp ; jump
- The JEQ jump directive is activated, so the next instruction will be the value stored in A. 

# Module 2
Unit 0.3: The Hack Computer and Machine Language

2025/07/17

0000<->0500

- create, move, chunk of 16 bit
- ROM, is instruction memory
- instruction buses, data buses, address buses
- ROM is an abbreviation of read only memory
- maybe because it was a place stores instruction

# Module 2
Unit 0.2: Machine Language Elements

2025/07/15

1000<->1700

- mouse is connected to a certain register

# Module 2
Unit 0.2: Machine Language Elements

2025/07/13

0700<->1000 1000<->1500

- long address doesn't exist
- data registers
- address registers
- flow control

# Module 2
Unit 0.2: Machine Language Elements

2025/07/12

0000<->0700

- cost performance tradeoff
- arithmetic operations, logical operations, flow control
- access memory is expensive, need to supply a long address, getting the memory contents into the CPU take time
- memory hierarchy
- registers (in CU), cache, main memory, disk
- disk is also considered as memory


# Module 2
Unit 0.1: Machine Language Overview

2025/07/12

0900<->1200 End

Unit 0.1: Machine Language Overview | Coursera
.# Module 2
.Unit 0.1: Machine Language Overview


2025/07/04

- Turing, theory
- von Neumann, practice
- memory including program and data
- compilation is from machine language to high level language, java or python; assembler assembly language they are not high level language
- 0100010 0011 0010
- ADD R3 R2
- True or False: complier would translate high level language to machine language, assembler would translate assembly language to machine language
Coach
True. 
A compiler translates high-level programming languages (like Java or Python) into machine language.
An assembler translates assembly language (a low-level language) into machine language.
This distinction is important in understanding how programs are executed on a computer.

https://www.coursera.org/learn/nand2tetris2/lecture/TlovA/unit-0-1-machine-language-overview

# Week 1 Unit 0.1: Machine Language Overview

2024/10/17

000<->0400

- ALU
- theoretical model of computer
- universal machine, one machine 
- theory, turing, von neumann practice
- instructions and data send to CPU

------------------

# Week1

## 1-2

2023/03/22

- airline reservation system, from software
- high level code, complie to VM code,  translate it to machine language
- compiler, VM translator
- high level language is writting on a system

### 2-2 Unit 0.0 Module 0 # Week1-2-2 Unit0.0
2023/07/17

- delicate handshake
- substance
- subject


2022/12/23

- introduce the structure

2022/11/18

0000<->0500

- VM code to assembly code

### Week1.2-3

2023/11/11

0000<->0300

- one machine simulate all the other  machines

2023/11/11

- TBRT

### Unit 1.6
2022/10/11
1000<->End

- test scripts holds the anchors
- differentiate static and stack

### Unit 1.10 Perspective

2022/12/02

0806<->End

- JAVA byte code JAVA JVM
- hack VM 16 digits, it can only recognize integer
- both are stack base
- 1990 JAVA
- business and office application
- a universal VM architecture that can run on all the machines
- cross platform compitability
- nothing can stop a good idea, it has a life of its own
- sluggish
- stack vs register machine, register machine are more applicable for mobile devices

2022/10/28

0806<->End

- java's vm language, byte code
- hack vm language only recognize integer
- both are stack base, push and pop
- 1990s SUN java
- archar rival
- java can run on everything, even washing machine
- SUN want to connect everything
- java complier generates bite code? byte code
- register machine, stack architecture, types of vm architecture

2022/10/27

0000<->0806

- 1970s IBM apple, first PC, no software on them
- pascal run on mainframe
- different pascal compiler
- IBM apple have no interest to help developer to port their software on other company's machine
- translate P code to intel IBM, another P code translate to mortorola CPU apple
- pascal complier generate P code
- same pascal program on both IBM and Apple
- P code implementation can be easily downloaded and installed by then
